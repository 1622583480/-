# 2020.07.30
 - Vue.js容易和其他第三方库联合开发 
 - 比如 uniapp 等 
知识点：今天学习了Vue的基本知识点 
比如 Vue的数据是实时渲染的 还有Vue是数据驱动视图 
剩下就指令 Vue的一些指令 
比如说 v-bind 让html标签的属性值 变成一个变量 
还有动态插值 {{变量名}}
    还有v-html可以在一个标签里面插入另一端html标签 
    v-if v-else v-for
    三个语句 他们也都是实时更新的 单独的给一个html元素设置
    v-if v-else 
    他们会设置这个html元素是否隐藏
    同时他们还可以搭配for循环去进行过滤操作 

    还有双向绑定的v-model 他可以将例如input的value值
    实时绑定到一个变量上面 他们可以互相绑定
    无论是value改变还是变量改变 都会影响到  对方的值 
    
    条件渲染 
    v-for和v-if的结合 
# 2020.08.01
click点击时,checkbox的状态还没有发生改变，所以拿到的总是相反的，change可以保证只当值变化后再触发函数

# 2020.08.07
<!-- 当然这种方式一般用于在组件内动态添加内容的时候  -->
    插槽也是父元素向子元素传值的一种方式

    这种方式可以直接在子元素的html代码中任意一个地方 让父元素传值过来 或者传html代码块等等等

    插槽标签如果有多个 且不写name属性的话 父元素只有一个传值 
    那么子元素所有的 <slot></slot>内的内容都会被替换为 父页面传值的内容 

    插槽 <slot></slot>  还有具名插槽<slot name="content" ></slot>
    你可以在父组件调用的时候 可以 
    <btnsole>
    <!-- 这里用template的原因是 template代表的是一个空的标签 不会改变原有的标签结构 -->
    而我们又需要用很多v-slot 所以最好用的就是空标签 
    <template  v-slot:title>Hello World</template>
    <template  v-slot:content>提 交</template>
    </btnsole>
 - 数据通信:{
      - vue的单项数据流 
      props传递过来的数据 不允许在子组件当中直接修改
      而是通过this.$emit通知父组件 让父组件去修改 这种修改方式就单项数据流
 }
 - 另类的双向绑定 <one :title.sync="msg">
 将msg传递给子组件 
子组件通过$emit 触发事件:并自动修改父组件中的msg
sync作用: 会[扩展] 成一个更新父组件绑定值的v-on监听器
<!-- 子组件用通过$emit('updata:title')触发事件 -->
传bind绑定的msg 改也是改父组件里面的msg
 - vue当中的一些$
 - $refs.alert.$el 
 获取一个组件绑定了 ref的根元素 
 - $children[2]
 获取子组件中的对象 方法 变量  获取第二个子组件
 不包含子组件的子组件
 - $parent 
 获取 一个父组件
 - $data  this.$data.msg = 'aaaaaa' 不建议这样去修改 
 返回当前组件中data里面的数据

### 总结 数据通信的十三种方案
 - props 父传子 单项数据流
   - 父组件自定义属性绑定值
   - 子组件通过props接收
 - $emit 子传父 单选数据流
   - 父组件绑定自定义事件
   - 子组件this.$emit 触发 自定义事件:并传值

 - .sync 数据双向绑定 
   - 父组件v-bind:属性 .sync="数据" --->传值
   - 子组件this.$emit (updata:数据,修改的值)
 - $chilren 返回当前组件下子组件的集合,不适合修改 仅适合获取
   - ------>单项数据流

 - $parent 
   - 返回当前组件的父组件对象
   - 获取父组件中的所有变量和方法
   - 单项数据流 
   - 可以执行父组件方法; 修改自己的数据

- ref $refs
   - 给组件绑定ref属性
   - 获取绑定ref 数据的组件对象
   - $refs.$el 返回dom元素

- v-bind v-model
   - v-bind数据单项绑定
   - v-model数据双向绑定

- $attr $listeners
   - 

- provide & inject
   - 高阶组件;封装组件库用得到
   - provide 父组件提供属性
   - inject 子组件接收属性

- localStorage & sessionStorage
   - localStorage 浏览器做数据持久化
   - sessionStorage 数据临时存储 关闭浏览器消失

- 边界条件
边界条件主要通过vue的三个实例属性实现根组件,父组件,子组件之间的数据传递

vm.$parent:当前组件的父实例.
vm.$root:组件树的根实例,如果没有父实例,vm.$root指向自己.
vm.$refs:注册过 ref 特性 的所有 DOM 元素和组件实例.

ref 与 $ref
ref用于给子元素或子组件注册引用信息
$ref是非响应式的,在组件渲染完成之后生效，只能用于父组件拿到子组件实例，不能跨级
任意设置了ref属性的子组件标签，都可以在其父组件中通过this.$refs.refvalue拿到对应的实例
 - 非父子组件的通信
   - 

- 事件总线
   - 

- vue路由传参
   - 
 - vueX
# 2020.08.08 
自己总结 问题点: vue cli是什么 vuecli有什么用 里面一些文件夹 和文件的作用具体代表什么
-----> 代表同级目录 
-----> -----> 代表该文件夹下的目录或者文件
----->  代表该文件夹下的分支
   - 
 
 vue cli 简称vue脚手架 代表的是vue的开发环境 

----->  node_modules// 项目依赖的模块
-----> src// 源码目录 
   -  assets// 资源目录 vue cli自动会放入一个图片在里面作为初始页面的logo。
   平常我们使用的时候会在里面建立js，css，img，fonts等文件夹，作为静态资源调用
   - components// vue公共组件 

-----> public 公开资源目录 用户可以直接访问
   -  index.html// 入口页面
-----> package.json// 项目基本信息
-----> README.md// 项目说明
-----> App.vue// 页面入口文件（根组件）
-----> main.js// 程序入口文件（入口js文件）

// 以下暂时无需了解 
-----> .babelrc// ES6语法编译配置
-----> .editorconfig// 定义代码格式
-----> .gitignore// git上传需要忽略的文件格式
-----> router// 前端路由 -----> index.js 路由配置文件


专业术语介绍:软件开发环境(Software Development Environment，SDE)是指在基本硬件和宿主软件的基础上，为支持系统软件和应用软件的工程化开发和维护而使用的一组软件，简称SDE。它由软件工具和环境集成机制构成，前者用以支持软件开发的相关过程、活动和任务，后者为工具集成和软件的开发、维护及管理提供统一的支持.
   正式介绍: 开发环境 ----> 测试环境 -----> 生产环境 
开发环境：开发环境时程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告和测试工具，是最基础的环境。开发环境的分支，一般是feature分支。

测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产服务器上，是开发环境到生产环境的过度环境。测试环境的分支一般是develop分支，部署到公司私有的服务器或者局域网服务器上，主要用于测试是否存在bug，一般会不让用户和其他人看到，并且测试环境会尽量与生产环境相似。

生产环境： 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志，是最重要的环境。部署分支一般为master分支。

三个环境也可以说是系统开发的三个阶段：开发->测试->上线，其中生产环境也就是通产说的真实的环境，最后交给用户的环境。

我们安装的 vue cli 就属于vue框架的开发环境

# 2020.08.10
   - 在Vue Cli中生命周期函数是组件的生命周期函数 
   - 组件中的this指向的当前组件的实例 
### 周作业自己实现原理 
1.实现疑问
   - 利用特性: 子组件表单提交一次会刷新一次 下面的列表作为子组件
   - 也会自动刷新所以说也是触发created钩子函数的 
   - 一级商商家列表把localStorage作为自己的数据库 
   - 每一次添加的时候都会把shopList 存到localStorage
   - 而每一次提交刷新的时候也会从localStorage Get数据
   - 且还会向下传参到子组件 商品列表 
   - 所以子函数不需要去从localStorage拿参数就可以实现动态添加存储
2.二级商品页面和购物车同步
   - 他们使用的都是同一个localStorage里面的对象 
   - 同时操作同一个数据 实现另类双向绑定 
   - 只不过商品页并没有渲染动态值 
3.已知未解决问题
   - 当用户在商品页加入购物车的时候 下面的已勾选商品的价格并不会动态增长价格 

### 路由
   - 什么是路由?  (简单来说的案例就是tab切换)

# 2020.08.12
规则 单项数据流  响应式数据 
   vueX数据管理 是一个状态管理模式 
   可以解决孙 子 组件通信繁琐问题 
   路由组件 组件通信问题 
   非关系组件 ;多组件之间的通信问题 
   只是用代码实现的一个[临时]的数据存储机制 
   存储大小无限制
   注意临时 刷新后 vuex数据回到初始化状态 
   所以vuex中部分数据需要做持久化操作 
   如何在vue中做数据持久化问题

   - 安装vuex 
   - vue add vuex --save
   
   this.$store.dispath("noticeUserInfo",{
      userName:"wyh",
      iphone:"123345567789",
      password:"123456",
   });
   // dispath 触发actions中的函数 参数函数名称 参数二传实参
   // 获取 内容 


   在一个组件中想要快速获取vuex中的内容而不想通过一些繁琐的方式 
   可以在想要获取的组件中 引入
   improt { mapGetters } from 'vuex'
   然后直接在计算属性(componed) 里面
   ...mapGetters({
      token:'getToken',
   });  // 这是一种快速获取的方法 仅仅只是写法不同 

   还有一种 快速给与的方式 
   一样的引入只不过是引入的 
   improt { mapActions } from 'vuex' 这里就需要放在 methods中 
   ...mapActions([noiceUserInfo])
   this.noiceUserInfo({
      UserName:'1231',
      password:'123123',
   });
   这一段直接调用了Actions中的 noiceUserInfo 然后传入一个对象 

   vuex做数据持久化 
   local storage

   axios 
   - 在plugins里面写入总接口  
   - 总接口一样 只不过子接口不同 
   比如 www.baidu.com/list www.baidu.com/miseue
   所以我们在api 里面对应文件需要的请求 
   和之前一样 暴露一个函数 在组件中引入 对应的函数 
   然后直接than 表示成功的结果直接拿到 
   当然 请求参数也可以是动态的 由组件中传值 

## 跨域拦截 2020.08.17
   gttp://www.xxx.com.api/xxx
   协议/域名/路由构成
   - 1. 协议不同
   - 2. http://www.xxx.aaa.com/api/xxx 请求子域名
   - 3. 路由不同
   都会产生跨域拦截
只会在[浏览器]中才会有跨域拦截 [cors]浏览器任务认为部分服务的请求存在安全隐患,所以拦截掉了 
#### 如何解决跨域拦截 
   - 方式1. 不受浏览器控制 
   1. script标签不会受到浏览器同源策略的影响 jsonp通过重写script加载资源
   解决掉跨域拦截 
   2. 让服务器请求服务器是不存在跨域拦截的  代理服务器 
      - 让本地服务请求跨域拦截的 服务器 
      - 让浏览器请求本地服务  这里的本地服务器就属于代理服务器 
   - 方式二:
      -工程化中 cli 已经处理好代理 服务器 写配置项 
       - vue.config.js文件中 写 
   - 还可以用axios做代理 
 # 2020.08.18 路由导航守卫
